/**
 * Copyright (c) 2017-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "FusingOptimizer.h"
#include <torch/csrc/jit/passes/subgraph_rewrite.h>

namespace glow {

// This is mainly copied from pytorch/tvm
// This pass fuse the addmm or matmul + add generated by JIT back to linear
// to allow direct support with Glow integration with Glow IR
// This pass can be deleted once the JIT can emit the aten::linear in the future
void FuseLinear(std::shared_ptr<torch::jit::Graph> &graph) {
  std::string addmm_pattern = R"IR(
graph(%input, %weight, %bias, %4):
  %weight_t = aten::t(%weight)
  %res = aten::addmm(%bias, %input, %weight_t, %4, %4)
  return (%res))IR";
  std::string matmul_add_pattern = R"IR(
graph(%input, %weight, %bias, %4):
  %weight_t = aten::t(%weight)
  %output = aten::matmul(%input, %weight_t)
  %res = aten::add_(%output, %bias, %4)
  return (%res))IR";
  std::string mm_add_pattern = R"IR(
graph(%input, %weight, %bias, %4):
  %weight_t = aten::t(%weight)
  %output = aten::mm(%input, %weight_t)
  %res = aten::add_(%output, %bias, %4)
  return (%res))IR";
  std::string fused_linear = R"IR(
graph(%input, %weight, %bias, %4):
  %res = aten::linear(%input, %weight, %bias)
  return (%res))IR";

  std::string matmul_pattern = R"IR(
graph(%input, %weight):
  %weight_t = aten::t(%weight)
  %output = aten::matmul(%input, %weight_t)
  return (%output))IR";
  std::string mm_pattern = R"IR(
graph(%input, %weight):
  %weight_t = aten::t(%weight)
  %output = aten::mm(%input, %weight_t)
  return (%output))IR";
  std::string fused_linear_bias_none = R"IR(
graph(%input, %weight):
  %bias: Tensor? = prim::Constant()
  %res = aten::linear(%input, %weight, %bias)
  return (%res))IR";

  // replace addmm pattern to linear
  torch::jit::SubgraphRewriter addmm_to_linear;
  addmm_to_linear.RegisterRewritePattern(addmm_pattern, fused_linear);
  addmm_to_linear.runOnGraph(graph);

  // replace matmul + add pattern to linear
  torch::jit::SubgraphRewriter matmuladd_to_linear;
  matmuladd_to_linear.RegisterRewritePattern(matmul_add_pattern, fused_linear);
  matmuladd_to_linear.runOnGraph(graph);

  // replace mm + add pattern to linear
  torch::jit::SubgraphRewriter mmadd_to_linear;
  mmadd_to_linear.RegisterRewritePattern(mm_add_pattern, fused_linear);
  mmadd_to_linear.runOnGraph(graph);

  // replace matmul with bias=None pattern to linear
  torch::jit::SubgraphRewriter matmul_to_linear;
  matmul_to_linear.RegisterRewritePattern(matmul_pattern,
                                          fused_linear_bias_none);
  matmul_to_linear.runOnGraph(graph);

  // replace mm with bias=None pattern to linear
  torch::jit::SubgraphRewriter mm_to_linear;
  mm_to_linear.RegisterRewritePattern(mm_pattern, fused_linear_bias_none);
  mm_to_linear.runOnGraph(graph);
}

} // namespace glow
