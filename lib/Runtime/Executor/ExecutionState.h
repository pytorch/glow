/**
 * Copyright (c) Glow Contributors. See CONTRIBUTORS file.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#ifndef GLOW_RUNTIME_EXECUTOR_EXECUTIONSTATE_H
#define GLOW_RUNTIME_EXECUTOR_EXECUTIONSTATE_H

#include "glow/Runtime/RuntimeTypes.h"
#include "glow/Support/TensorPool.h"
#include "glow/Support/ThreadPool.h"

namespace glow {
namespace runtime {

/// This class keeps track of the state of execution for a run (identified
/// by the runId).
class ExecutionState final {
public:
  /// Constructor.
  explicit ExecutionState(RunIdentifierTy id, const DAGNode *root,
                          ThreadExecutor *executor,
                          std::unique_ptr<ExecutionContext> resultContext,
                          ResultCBTy doneCb);

  /// Does the BFS traversal and initializes the ExecutionState.
  void init();

  /// \returns a unique pointer to an input bindings for \p node. This should
  /// not be called at the same time as insertIntoNodeCtx().
  std::unique_ptr<ExecutionContext>
  getUniqueNodeContextPtr(const DAGNode *node);

  /// Increment the count of inflight nodes by \p increment (default is 1).
  void incrementInflightNodes(unsigned increment = 1);

  /// Decrement the count of inflight nodes by the \p decrement (default is 1).
  /// \returns true if there are no nodes inflight after the decrement
  /// operation.
  bool decrementInflightNodes(unsigned decrement = 1);

  /// Increment the count of completed parent nodes for \p node. \returns
  /// true if all parents are done after the increment operation, false
  /// otherwise.
  bool incrementNodeParentsDone(const DAGNode *node, unsigned increment = 1);

  /// Move all events from the provided vector into the top level resultContxt.
  void insertIntoTraceContext(TraceContext *runCtx);

  /// Remove intermediate placeholders not required in the final output.
  void removeIntermediatePlaceholders();

  /// \returns a unique pointer to the result bindings. This should not be
  /// called at the same time as getRawResultPlaceholderBindingsPtr() or
  /// insertIntoResultCtx().
  std::unique_ptr<ExecutionContext> getUniqueResultContextPtr();

  /// \returns a raw pointer to the result bindings. This should be not called
  /// at the same time as getUniqueResultPlaceholderBindingsPtr().
  ExecutionContext *getRawResultContextPtr() const;

  /// \returns the callback for this execution.
  ResultCBTy getCallback() { return cb_; }

  /// \returns the OneErrOnly Error container for the execution.
  OneErrOnly &getErrorContainer() { return errContainer_; }

  /// \returns the run ID for the execution.
  RunIdentifierTy getRunId() const { return runId_; }

  /// \returns the Executor used for this run.
  ThreadExecutor *getExecutor() { return executor_; }

  /// Whether or not this node has been initialized.
  bool initialized_{false};

private:
  /// The run identifier for this execution of a DAG.
  RunIdentifierTy runId_;
  /// The callback that should be called when execution is done.
  ResultCBTy cb_;
  /// The ExecutionContext object containing the results of the execution
  /// (i.e. the outputs of the DAGNodes that have no children).
  std::unique_ptr<ExecutionContext> resultCtx_;
  /// Counters for how many of each nodes parents are done. These are needed
  /// in order to determine when a node is ready to be executed.
  std::unordered_map<const DAGNode *, std::atomic<unsigned>> nodeParentsDone_;
  /// Input contexts for all of the nodes. These are gradually
  /// populated as a node's parents finish.
  std::unordered_map<const DAGNode *, std::unique_ptr<ExecutionContext>>
      inputCtxs_;
  /// Placeholders for tensors generated by DAG nodes that aren't the final
  /// output (i.e. they have children). The owning pointer for these tensors
  /// exists in the resultCtx and are removed before the ResultCB is called.
  std::vector<Placeholder *> intermediatePlaceholders_;
  /// This is populated with the roots when a run starts, and does not become
  /// empty until execution finishes.
  std::atomic<unsigned> inflightNodes_;
  /// Value that is used to track if an Error was received.
  OneErrOnly errContainer_;
  /// Module for the network. This contains the PHs used by the functions in
  /// this network.
  Module *module_{nullptr};
  /// Root node of the DAG for this run.
  const DAGNode *root_;
  /// Object pool for intermediate tensors.
  TensorPool intermediateTensorPool_;
  /// Thread Executor used for this run.
  ThreadExecutor *executor_;
};

} // namespace runtime
} // namespace glow

#endif // GLOW_RUNTIME_EXECUTOR_EXECUTIONSTATE_H
